# {{description}} - Implementation

## Task Reference
- **Task ID**: {{taskId}}
- **Task URL**: {{taskUrl}}
- **Parent Task**: {{parentTask}}
- **Branch**: {{branchName}}

## Goal
Implement {{description}} efficiently with minimal disruption to ongoing development.

## Workflow
Patterns first → Test → Minimal impl → Refactor green → Commit message explains "why"

## Implementation Strategy
### Approach
- **Method**: Step-by-step approach to complete the work
- **Incremental**: Whether work can be done in phases
- **Risk Mitigation**: Steps to minimise impact on existing systems

### Coordination
- **Team Communication**: How to coordinate with other developers
- **Integration**: How changes integrate with ongoing work
- **Timeline**: Planned schedule and milestones

## Files and Components
### Files to Modify
- `path/to/file1.ext` - Description of changes
- `path/to/file2.ext` - Description of changes
- `config/settings.ext` - Configuration updates

### Files to Create
- `new/utility/file.ext` - Purpose and functionality
- `docs/process.md` - Documentation additions

### Files to Remove/Deprecate
- `old/legacy/file.ext` - No longer needed because...

## Implementation Steps
### Phase 1: Preparation
- [ ] Set up development environment
- [ ] Review existing code and understand current implementation
- [ ] Identify all affected components and dependencies

### Phase 2: Core Implementation
- [ ] Implement main functionality changes
- [ ] Update configuration files and settings
- [ ] Refactor code for improved maintainability

### Phase 3: Integration and Testing
- [ ] Integrate changes with existing codebase
- [ ] Run existing tests to ensure no regressions
- [ ] Add new tests if functionality warrants it

### Phase 4: Documentation and Cleanup
- [ ] Update relevant documentation
- [ ] Clean up temporary files or debugging code
- [ ] Review code for quality and consistency

## Technical Details
### Key Changes
- **Change 1**: Description and rationale
- **Change 2**: Description and rationale
- **Change 3**: Description and rationale

### Configuration Updates
- Environment variables or config file changes
- Database configuration updates if applicable
- Service configuration modifications

### Dependencies
- New libraries or tools introduced
- Version updates for existing dependencies
- Removal of unused dependencies

## Testing Strategy
### Validation Approach
- **Functional Testing**: Verify core functionality still works
- **Regression Testing**: Ensure no existing features broken
- **Performance Testing**: Check for performance impact if applicable

### Test Cases
- **Test 1**: Validation of primary objective
- **Test 2**: Verification of integration points
- **Test 3**: Edge case or boundary testing

## Risk Management
### Potential Risks
- **Risk 1**: Description and mitigation plan
- **Risk 2**: Description and mitigation plan
- **Rollback Plan**: How to undo changes if problems arise

### Monitoring
- Metrics to monitor after implementation
- Signs that would indicate issues with the changes
- Timeline for enhanced monitoring

## Knowledge Sharing
### Team Impact
- New processes or tools team needs to understand
- Changes to development workflow
- Training or documentation needs

### Documentation Updates
- **README updates**: Process or setup changes
- **Wiki updates**: Architecture or design documentation
- **Runbook updates**: Operational procedure changes

## Current Status
**Status**: Not Started
**Next Action**: Set up development environment and begin implementation
**Blockers**: None identified

## Actual Results
*To be filled upon completion*

## Lessons Learned
*To be captured during implementation*